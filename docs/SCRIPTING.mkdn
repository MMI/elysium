# Elysium scripting guide

* Version 1
* by Matt Mower <self@mattmower.com>
* 28/11/08

## Introduction

This is a quick guide I've hacked together to help you get started scripting Elysium 0.8. Please note that this information is in flux and some of these elements will very likely change, maybe quite radically.

Elsyium is implemented primarily in Objective-C which is a compiled language however it also embeds the [MacRuby virtual machine](http://www.macruby.org/trac/wiki/MacRuby) which is a full version of Ruby 1.9 designed for interoperability with Objective-C/Cocoa applications. Scripting Elsyium consists of writing Ruby-based callbacks (in the form of procs) in specific areas. There are 3 general types of callback.

1. willRun/didRun callbacks

  These are attached to scriptable elements such as the player, layers, and tokens and are invoked automatically before & after certain events.For example a note token can use it's willRun callback to decide if it should skip playing on this beat.
  
  <code>
    <pre>
      do |noteTool,playhead|
        # Don't play on even beats
        noteTool.skip = true if noteTool.layer.beatCount % 2 == 0
      end
    </pre>
  </code>
  
2. timer callbacks

  These live in the script package and are invoked whenever a timer runs out, e.g. every 30s. You might use this to bring in a layer at a certain point in a composition.

  <code>
    <pre>
      do |player,timer|
        # Every time the timer fires toggle the first & second layers enabled state
        player.layers[0].enabled = !player.layers[0].enabled
        player.layers[1].enabled = !player.layers[1].enabled
      end
    </pre>
  </code>
  
3. MIDI triggers

  These run in response to external MIDI CC events arriving in Elysium. You could use them to implement "poor man's MIDI learn" by controlling Elysium knob values using MIDI CC values. Or, really, do anything in response to MIDI CC info like triggering layers when you push buttons and so on.

  <code>
    <pre>
      do |player,message|
        # Connect MIDI CC to player tempo
        player.tempoKnob.value = message.value
      end
    </pre>
  </code>

## How Elysium works

Elysium generates music by sending MIDI note-on and note-off messages to various MIDI channels. The process by which is does this is somewhat as follows:

Each Elysium document contains a `player` that has at least one `layer`. Each `layer` is composed of `cells`, arranged in a honeycomb like structure, upon which tokens can be placed. When the player (and hence its layers) are running `generator` tokens emit `playheads` at regular intervals in a particular direction. On each beat each playhead moves one cell in its given direction and, as it enters a new cell, will trigger tokens stacked on that cell, e.g. a note. The tokens, in turn, can interact with the playhead by, for example, changing it's direction or absorbing it.

Each of these things: player, layer, token, playhead are a scriptable element and scripts get to interact with the system as it works to create subtle or gross changes of behaviour.

## Scriptable Elements

The scriptable elements represent the "moving parts" of Elysium that are responsible for generating music: player, layers, cells, tokens, and playheads.

Elysium has a hierarchical structure composed as follows:

<ul>
  <li>
    player
    <ul>
      <li>
        layer
        <ul>
          <li>
            cell
            <ul>
              <li>token</li>
              <li>playhead</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

At each level there are properties that may be inherited from the level above. For example the duration of a note played has a setting at the player level that is inherited by each layer and, in turn, by each note token on a cell on each layer.

However a layer may override the inherited value with its own default duration that will be inherited by its cells. Further a note on any particular cell can be given it's own specific value separate from other notes on cells of the same layer.

## Properties

In many cases a property will not be a simple variable but will be represented by a `knob`. Many properties in Elysium can have dynamic values (for example you can attach an oscillator to player tempo to vary the speed of a performance over time) and the knob concept encapsulates the information required to have both manually assigned and dynamic values.

Each knob has it's own set of properties:

* name

  A string containing the name of the knob, e.g. 'duration'.

* linkedKnob

  A pointer to a knob, in the parent element, from which this knob may inherit its value.

* linkValue

  A boolean representing whether this knob determines its own value or inherits it from its linkedKnob.

* oscillator

  A pointer to an oscillator that can dynamically supply the value of this knob.

* value

  A Boolean, Integer, or Float depending upon the type of knob.

* dynamicValue

  If an oscillator is installed the next value from the oscillator.

## Player

Each Elysium document has one player responsible for grouping all the scriptable elements. The player is composed of one or more layers and a scripting package.

### Player Properties

1. tempoKnob [integer]

  The tempoKnob value is represented in BPM.

* barLengthKnob [integer]

  How many beats in a "bar". The Elysium concept of a 'bar' is pretty woolly. Essentially Elysium will play any note corresponding to the first beat of a bar usnig the emphasis velocity rather than the default velocity.

* timeToLiveKnob [integer]

  For generators in this player, how many beats each emitted playhead should live.

* pulseCountKnob [integer]

  For generators in this player, how many beats between playheads being emitted.

* velocityKnob [integer]

  For notes in this player, the default MIDI velocity when a note is played.

* emphasisKnob [integer]

  For notes in this player, the emphasis MIDI velocity when a note is played. (See barLengthKnob for more info).

* durationKnob [float]

  For notes in this player, the number of seconds a note is played (i.e. the time between MIDI note-on and note-off messages)

* transposeKnob [integer]

  For notes in this player, the number of notes by which played notes are transposed up or down.

* layers

  An array containing the layer objects this player is running. I suggest treating this as read-only right now. There is more information about layers later in this guide.

* triggers

  An array containing the MIDI triggers. I suggest treating this as read-only right now. There is more information about MIDI triggers later in this guide.

* pkg

  A pointer to the script package for this player. There is more information about the scripting package later in this guide.

## Layer

A layer is a surface composed of 204 hexagonal cells arranged in 17 columns of 12 rows each. The cells form a harmonic table where each cell represents one note (in octaves 1-7). The bottom left note is A#1 whilst the top right note is B7. For more information see: http://www.c-thru-music.com/cgi/?page=layout_notemap

Each layer also represents, generally, one MIDI channel. Although this is completely configurable as new layers are created they will be assigned MIDI channels 2, 3, 4, etc. However multiple layers can be safely assigned the same MIDI channel and any note can be overriden to send to any of the MIDI channels.

Each cell may contain any of a number of tokens that determine what happens when a playhead enters the cell. The exception is the generator token which emits new playheads at specific intervals, rather than when playheads arrive (by comparison see the split token).

### Layer Properties

1. enabledKnob [boolean]

  Determines whether the layer runs or not.

* channelKnob [integer]

  Controls which MIDI channel notes on the layer send to. Value can range from 1 to 16.

* tempoKnob [integer,inherited]

  See Player#tempoKnob.

* barLengthKnob [integer,inherited]

  See Player#barLengthKnob.

* timeToLiveKnob [integer,inherited]

  See Player#timeToLiveKnob.

* pulseCountKnob [integer,inherited]

  See Player#pulseCountKnob.

* velocityKnob [integer,inherited]

  See Player#velocityKnob.

* emphasisKnob [integer,inherited]

  See Player#emphasisKnob.

* durationKnob [float,inherited]

  See Player#durationKnob.

* tranposeKnob [integer,inherited]

  See Player#transposeKnob.

## Cells

The cell API will be described in a future version of this guide.

## Tokens

A token is placed on a cell and (with one exception) creates an effect as a playhead enters cell. Each cell can have multiple tokens stacked on it to create different combinations of effect. It is legal, for example, to combine a generator, note, rebound, and, absorb token on the same cell. Within reason Elysium will try to do the right thing so, in the given example, the absorb and rebound tokens will only affect playheads entering the cell and not those emitted by the generator.

Note that the terminology in the app is that _tokens_ are called _tools_. This is legacy terminology that will be eliminated before 1.0 where you will refer to `noteToken` and not `noteTool`.

### Token Properties

1. enabled
  
  A boolean property (not a knob) that indicates whether the token is enabled. A disabled token does not run at all so you cannot use it's own callbacks to re-enable it.

* hex (will be renamed 'cell')

  A reference to the cell this token sits on. 

## Generator Token

Generator tokens are polled, on each beat, to see if they should emit a new playhead.

### Generator Token Properties

1. enabled

* pKnob [integer,not inherited,default=100]

  The probability that this generator will emit a new playhead when the beat count reaches its pulseCount.

* directionKnob [integer,not inherited,default=0]

  The value of this knob indicates the compass direction in which new playheads will begin. These are:

  0: N
1: NE
2: SE
3: S
4: SW
5: NW

* timeToLiveKnob [integer,inherited]

  See Layer#timeToLiveKnob

* pulseCountKnob [integer,inherited]

  See Layer#pulseCountKnob

* offsetKnob [integer,not inherited,default=0]

  The offet represents the number of beats before or after the pulseCount beat that this generator will emit a new playhead. That is a generator will offsetKnob value set to 1 will emit a playhead one beat later than one with the default of 0.

## Note Token

Note tokens are the heart of Elysium since it is these that generate the MIDI on and MIDI off messages that actually make your instruments play! Whenever a playhead passes over an enabled note token it will generate MIDI to play the note corresponding to it's cell in the harmonic table. To see which cells correspond to which notes turn on display of notes in the Layer menu.

### Note Token Properties

1. enabled

* pKnob [integer,not inherited,default=100]

* velocityKnob [inherited]

  See Layer#velocityKnob.

* emphasisKnob [inherited]

  See Layer#emphasisKnob.

* durationKnob [inherited]

  See Layer#durationKnob.

* triadKnob [integner,not inherited,default=0]

  The value of this knob indicates, when a note is played, whether a triad is played. 0 means no triad is played, other values correspond to the triad groups: [insert groups here]

* overrideKnob [boolean,not inherited,default=false]

  When the value of this knob is set to `true` the MIDI channel information from the layer is ignored and note information is sent for every channel that is enabled in the `channelSends` array.

* channelSends [not inherited]

  An array of boolean knobs, one for each channel, that indicate whether MIDI information should be sent to that channel or not.

## Rebound Token

Rebound tokens change the direction of playheads that pass over them.

### Rebound Token Properties

1. enabled

* pKnob [integer,not inherited,default=100]

* directionKnob [integer,not inherited,default=0]

  The value of this knob indicates the compass direction to which entering playheads will be redirected. These are:

  0: N
1: NE
2: SE
3: S
4: SW
5: NW

### Absorb Token

Absorb tokens destructively consume playheads that pass over them. This is, typically, the last token to be processed so an entering playhead will trigger notes and splits. Newly generated playheads will not be absorbed.

1. enabled

* pKnob [integer,not inherited,default=100]

## Split Token

A split token consumes the entering playhead and emits new playheads in all directions except the direction of the entering playhead (although see the bounceBackKnob). These _cloned_ playheads keep the remaiinng time to live of the original playhead.

### Split Token Properties

1. enabled

* pKnob [integer,not inherited,default=100]

* bounceBackKnob [boolean,not inherited,default=false]

  When `true` a clone playhead is sent back in the direction the entering playhead came from (i.e. a playhead will be emitted in all 6 compass directions).

## Spin Token

Unlike the other tokens the spin token operates on generate and rebound tokens on the same cell. When the a playhead crosses the spin token the direction of any generator or rebound tokens on the same cell is altered.

### Spin Token properties

1. enabled

* pKnob [integer,not inherited,default=100]

* clockwiseKnob [boolean,not inherited,default=true]

  If the `value` is `true` then the direction will be stepped clockwise, otherwise anti-clockwise.
  
* steppingKnob [integer,not inherited,default=1]

  The `value` determines the number of steps (compass points) by which the direction is changed.

## Tripwire Token

The tripwire token exists soley for the purpose of firing callbacks when a playhead passes over.

Tripwire tokens are not implemented in Elysium 0.8

## Oscillators

Oscillators can be attached to any integer or float knob and generate dynamic values within the range of acceptable values for the knob. There are a number of different types of oscillator.

1. Square
2. Saw
3. Sine
4. Sequence
5. Random

The API for the oscillators will be described in a future version of this document.

## The Script Package

The script package is a means to expose variables, that can be used by script authors, to the UI of the application.

The current script package contains 8 flags, 8 sliders, and 4 timers. The user can display the script package using the View menu's `Show Script Package` command.

### Flags

The flags are boolean properties labelled `f1` ... `f8`

### Variables

The variables are float properties labelled `v1` ... `v8`. For each variable there are corresponding properties to specify the minimum and maximum values, e.g. `v1min` and `v1max`.

### Timers

The timers are pointers to timer callback objects, labelled `timer1` ... `timer4` that have their own associated delay and scripts. Whenever a timer fires its associated ruby script is invoked with a reference to the player (through which it can access the script package, layers, and the rest of Elysium), and the timer that has expired. The timer API will be described in a later version of this guide.

## MIDI Scripting

Elysium can process incoming MIDI CC messages and route them to callback scripts called MIDI triggers. To see the MIDI configuration use the View menu | Show MIDI Configuration. Whenever a MIDI trigger is called it is called with a reference to the player (through which it can access the script package, layers, and the rest of Elysium), the MIDI CC number and the CC value. The MIDI trigger API will be described in a later version of this guide.
